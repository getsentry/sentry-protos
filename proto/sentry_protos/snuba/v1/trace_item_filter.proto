syntax = "proto3";

package sentry_protos.snuba.v1;

import "sentry_protos/snuba/v1/trace_item_attribute.proto";

enum TraceItemName {
  TRACE_ITEM_NAME_UNSPECIFIED = 0;
  TRACE_ITEM_NAME_EAP_SPANS = 1;
  TRACE_ITEM_NAME_EAP_ERRORS = 2;
}

message AndFilter {
  repeated TraceItemFilter filters = 1;
}

message OrFilter {
  repeated TraceItemFilter filters = 1;
}

message NotFilter {
  repeated TraceItemFilter filters = 1;
}

message ComparisonFilter {
  enum Op {
    OP_UNSPECIFIED = 0;
    OP_LESS_THAN = 1;
    OP_GREATER_THAN = 2;
    OP_LESS_THAN_OR_EQUALS = 3;
    OP_GREATER_THAN_OR_EQUALS = 4;
    OP_EQUALS = 5;
    OP_NOT_EQUALS = 6;
    OP_LIKE = 7; //string only
    OP_NOT_LIKE = 8; //string only
    OP_IN = 9; // array only
    OP_NOT_IN = 10; // array only
  }
  AttributeKey key = 1;
  Op op = 2;
  AttributeValue value = 3;
}

message ExistsFilter {
  AttributeKey key = 1;
}

// Represents a condition on searching for a particular "trace item"
// (e.g., spans, replays, errors)
message TraceItemFilter {
  oneof value {
    AndFilter and_filter = 1;
    OrFilter or_filter = 2;
    NotFilter not_filter = 3;
    ComparisonFilter comparison_filter = 4;
    ExistsFilter exists_filter = 5;
  }
}

// Wraps a TraceItemFilter and specifies the trace item name,
// to be used for cross-event queries.
message EventFilter {
  TraceItemName trace_item_name = 1;
  TraceItemFilter filter = 2;
}

message AndTraceFilter {
  repeated TraceFilter filters = 1;
}

message OrTraceFilter {
  repeated TraceFilter filters = 1;
}

message NotTraceFilter {
  repeated TraceFilter filters = 1;
}

// Represents a set of conditions for finding particular events
// in a trace. Each EventFilter is meant to find one particular
// type of event. Those can then be combined to find traces that
// contain different combinations of events.
message TraceFilter {
  oneof filter {
    AndTraceFilter and_filter = 1;
    OrTraceFilter or_filter = 2;
    NotTraceFilter not_filter = 3;
    EventFilter event_filter = 4;
  }
}
